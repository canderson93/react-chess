{"version":3,"sources":["data/board.js","data/rules/GameRule.js","data/rules/MoveRule.js","data/rules/MoveBishopRule.js","data/rules/MoveKingRule.js","data/rules/MoveKnightRule.js","data/rules/MovePawnRule.js","data/rules/MovePawnTwoRule.js","data/rules/MoveQueenRule.js","data/rules/MoveRookRule.js","data/rules/CastleRule.js","data/rules/MustBlockCheckRule.js","data/rules/KingMoveToCheckRule.js","data/rules.js","data/rules/PinnedPieceCheckRule.js","data/rules/CheckmateRule.js","data/rules/NoMoveStatelmateRule.js","data/store.js","components/Tile.js","components/Board.js","components/App.js","serviceWorker.js","index.js"],"names":["Board","board","Object","classCallCheck","this","x","y","length","from","to","xDirection","yDirection","Math","abs","tiles","push","getTile","pieces","forEach","row","tile","piece","getAllPieces","filter","type","player","actions","_this","parsedBoard","rows","split","splice","yIndex","map","xIndex","token","trim","parsePlayer","parsePiece","tileObject","charAt","GameRule","state","action","MoveRule","getAllPiecesOfType","markAllowedMoves","bind","selectedTile","allowedMoves","move","currentTile","attackAction","moveAction","repeat","pinnedAction","MoveBishopRule","MoveKingRule","MoveKnightRule","MovePawnRule","direction","MovePawnTwoRule","allowedRank","MoveQueenRule","MoveRookRule","CastleRule","kingFrom","kingTo","rookFrom","rook","rookTo","rookTile","kingRook","queenRook","hasMoved","setupCastle","king","canCastle","castleTile","castleTiles","getTilesBetween","moved","history","item","MustBlockCheckRule","pruneMoves","attackPiece","attackTiles","filterTile","getPlayerPieces","allowedAction","attackTile","console","log","actionIndex","indexOf","KingMoveToCheckRule","GameRules","pinnedPiece","checkForWinner","getAttackingPieces","checkmate","winner","message","stalemate","defaultState","parseBoard","store","createStore","arguments","undefined","assign","rule","execute","clearState","atTurnStart","beforeMove","stateCheck","toStore","Tile","props","concat","legal","_this2","dispatch","isLegal","selected","react_default","a","createElement","id","data-x","data-y","className","getPiece","onClick","handleClick","Component","connect","charCode","charCodeAt","output","counter","key","String","fromCharCode","components_Tile","drawBoard","apply","col","parseInt","App","es","components_Board","Boolean","window","location","hostname","match","ReactDOM","render","components_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7b122c4c.chunk.js","sourcesContent":["\nclass Board {\n    board = [];\n\n    constructor(board) {\n        this.board = board;\n    }\n\n    /**\n     * Gets the tile at the x, y position on the board\n     * @param x\n     * @param y\n     * @returns {*}\n     */\n    getTile(x, y) {\n        if (y < 0 || y >= this.board.length) { return null; }\n        if (x < 0 || x >= this.board[0].length) { return null; }\n\n        return this.board[y][x];\n    }\n\n    getTilesBetween(from, to) {\n        let x = from.x;\n        let y = from.y;\n\n        let xDirection = to.x - from.x;\n        let yDirection = to.y - from.y;\n\n        // We can only move along compass points, or diagonals\n        if (Math.abs(xDirection) !== Math.abs(yDirection) && xDirection !== 0 && yDirection !== 0)\n            return [];\n\n\n        const tiles = [];\n\n        // Normalise the direction so it's either 0, 1 or -1\n        xDirection = xDirection / Math.abs(xDirection) || xDirection;\n        yDirection = yDirection / Math.abs(yDirection) || yDirection;\n\n        while (x !== to.x || y !== to.y) {\n            tiles.push(this.getTile(x, y));\n\n            x += xDirection;\n            y += yDirection;\n        }\n\n        return tiles;\n    }\n\n    getAllPieces() {\n        const pieces = [];\n\n        this.board.forEach(row => {\n            row.forEach(tile => {\n                if (tile.piece) {\n                    pieces.push(tile);\n                }\n            })\n        });\n\n        return pieces;\n    }\n\n    getAllPiecesOfType(piece) {\n        return this.getAllPieces().filter((tile) => tile.piece.type === piece);\n    }\n\n    getPlayerPieces(player) {\n        return this.getAllPieces().filter((tile) => tile.piece.player === player);\n    }\n\n    clearState() {\n        this.board.forEach(row => {\n            row.forEach(tile => {\n                tile.actions = [];\n\n                if (tile.piece) {\n                    tile.piece.actions = [];\n                }\n            })\n        })\n    }\n\n    toStore() {\n        return this.board;\n    }\n\n    static parseBoard(board) {\n        let parsedBoard = [];\n\n        let rows = board.split(';');\n        rows.splice(rows.length - 1, 1); //the final ; creates an off-by-one error, so remove the last element\n\n        //Split the rows, and trim the results\n        rows.forEach((row, yIndex) => {\n            let tiles = row.split(',');\n            tiles = tiles.map((tile, xIndex) => {\n                let token = tile.trim();\n                let piece = null;\n                if (token) {\n                    piece = {\n                        player: this.parsePlayer(token),\n                        type: this.parsePiece(token),\n                    }\n                }\n\n                let tileObject = {\n                    x: xIndex,\n                    y: yIndex,\n                    piece: piece\n                };\n\n                // set up two-way reference between piece and tile\n                if (piece) {\n                    piece.tile = tileObject;\n                }\n\n                return tileObject;\n            });\n\n            parsedBoard.push(tiles)\n        });\n\n        return parsedBoard\n    }\n\n\n    static parsePlayer(token) {\n        if (typeof(token) !== 'string' && token.length !== 2) {\n            return null;\n        }\n\n        switch (token.charAt(0)) {\n            case 'B':\n                return 'black';\n            case 'W':\n                return 'white';\n            default:\n                return null;\n        }\n    }\n\n    static parsePiece(token) {\n        if (typeof(token) !== 'string' && token.length !== 2) {\n            return null;\n        }\n\n        switch (token.charAt(1)) {\n            case 'K':\n                return 'king';\n            case 'Q':\n                return 'queen';\n            case 'B':\n                return 'bishop';\n            case 'R':\n                return 'rook';\n            case 'N':\n                return 'knight';\n            case 'P':\n                return 'pawn';\n            default:\n                return null;\n        }\n    }\n}\n\nexport {\n    Board\n};","\nclass GameRule {\n\n    /**\n     * Hook to apply this rule at the start of a turn\n     * Use this to mark allowed moves and attacks based on the current board state\n     * @param state\n     * @return new state\n     */\n    static atTurnStart(state) {return state;}\n\n    /**\n     * Hook to apply this rule before the current player takes a move\n     * Use this to apply rules that depend on other game rules, for instance ensuring that players don't move into check\n     * @param state\n     * @returns new state\n     */\n    static beforeMove(state) {return state;}\n\n    /**\n     * Hook to check the game state for certain conditions after every other game rule has one\n     * Use this to check game's condition after all other rules have run.\n     *\n     * This hook should not modify the game state, except to declare a winner\n     *\n     * @param state\n     * @returns new state\n     */\n    static stateCheck(state) {return state;}\n\n    /**\n     * Execute moves based on this rule\n     * Use this to execute board state changes\n     * @param state\n     * @param action\n     * @return new state\n     */\n    static execute(state, action) {return state;}\n\n    /**\n     * Hook to apply this rule after the current player takes a move\n     * Use this hook to perform actions based on the previous move to update the game state for the next turn\n     * e.g. pawn promotion\n     * @param state\n     * @returns {*}\n     */\n    static afterMove(state) {return state;}\n\n}\n\nexport {\n    GameRule\n}","\nimport { GameRule } from './GameRule';\n\nclass MoveRule extends GameRule {\n    static allowedMoves = [];\n    static type = '';\n    static repeat = true; // apply allowedMoves repeatedly\n\n    static atTurnStart(state) {\n        const tiles = state.board.getAllPiecesOfType(this.type);\n        tiles.forEach(this.markAllowedMoves.bind(this, state));\n\n        return state;\n    }\n\n    static execute(state, action) {\n        if (action.type !== 'MOVE_PIECE') return state;\n        if (action.piece.type !== this.type) return state;\n\n        const from = state.selectedTile;\n        const to = action.tile;\n\n        from.piece = null;\n        to.piece = action.piece;\n        action.piece.tile = to;\n\n        return state;\n    }\n\n    static markAllowedMoves(state, tile) {\n        const piece = tile.piece;\n\n        this.allowedMoves.forEach(move => {\n            let {x, y} = tile;\n\n            x += move.x;\n            y += move.y;\n            let currentTile = state.board.getTile(x, y);\n\n            while (currentTile !== null) {\n                let attackAction = {\n                    type: 'ATTACK_PIECE',\n                    piece: piece,\n                    tile: currentTile,\n                    action: false\n                };\n                currentTile.actions.push(attackAction);\n                piece.actions.push(attackAction);\n\n                if (currentTile.piece && currentTile.piece.player === piece.player) break;\n\n                let moveAction = {\n                    type: 'MOVE_PIECE',\n                    piece: piece,\n                    tile: currentTile,\n                    action: true\n                };\n\n                currentTile.actions.push(moveAction);\n                piece.actions.push(moveAction);\n\n                if (!this.repeat) { break; }\n                if (currentTile.piece && currentTile.piece.player !== piece.player) {\n                    x += move.x;\n                    y += move.y;\n                    currentTile = state.board.getTile(x, y);\n\n                    // Once we've calculated what tiles a piece is attacking, and the available moves\n                    // we run the calculations further to see what pieces the tile *would* attack\n                    // if an attacked piece moved out of the way (used in check calculations)\n                    while (currentTile !== null) {\n                        if (currentTile.piece && currentTile.piece.player === piece.player) break;\n\n                        let pinnedAction = {\n                            type: 'ATTACK_PINNED',\n                            piece: piece,\n                            tile: currentTile,\n                            action: false\n                        };\n                        currentTile.actions.push(pinnedAction);\n                        piece.actions.push(pinnedAction);\n\n                        if (currentTile.piece && currentTile.piece.player !== piece.player) break;\n\n                        x += move.x;\n                        y += move.y;\n                        currentTile = state.board.getTile(x, y);\n                    }\n                    break;\n                }\n\n                x += move.x;\n                y += move.y;\n                currentTile = state.board.getTile(x, y);\n            }\n        });\n    }\n}\n\nexport { MoveRule };","\nimport { MoveRule } from './MoveRule';\n\nclass MoveBishopRule extends MoveRule {\n    static allowedMoves = [\n        {x: 1, y: 1},\n        {x: 1, y: -1},\n        {x: -1, y: 1},\n        {x: -1, y: -1}\n    ];\n    static type = 'bishop';\n    static repeat = true;\n}\n\nexport default MoveBishopRule;","\nimport { MoveRule } from './MoveRule';\n\nclass MoveKingRule extends MoveRule {\n    static allowedMoves = [\n        {x: 0, y: 1},\n        {x: 0, y: -1},\n        {x: 1, y: 0},\n        {x: 1, y: 1},\n        {x: 1, y: -1},\n        {x: -1, y: 0},\n        {x: -1, y: 1},\n        {x: -1, y: -1}\n    ];\n    static type = 'king';\n    static repeat = false;\n}\n\nexport default MoveKingRule;","\nimport { MoveRule } from './MoveRule';\n\nclass MoveKnightRule extends MoveRule {\n    static allowedMoves = [\n        {x: 1, y: 2},\n        {x: 1, y: -2},\n        {x: -1, y: 2},\n        {x: -1, y: -2},\n        {x: 2, y: 1},\n        {x: 2, y: -1},\n        {x: -2, y: 1},\n        {x: -2, y: -1}\n    ];\n    static type = 'knight';\n    static repeat = false;\n}\n\nexport default MoveKnightRule;","\nimport { MoveRule } from './MoveRule';\n\nclass MovePawnRule extends MoveRule {\n    static type = 'pawn';\n    static repeat = false;\n\n    static markAllowedMoves(state, tile) {\n        const piece = tile.piece;\n        const direction = piece.player === 'white' ? -1 : 1;\n        const {x, y} = tile;\n\n        // Check whether the pawn can move forward\n        let currentTile = state.board.getTile(x, y + direction);\n        if (currentTile && !currentTile.piece) {\n            let action = {\n                type: 'MOVE_PIECE',\n                piece: piece,\n                tile: currentTile,\n                action: true\n            };\n            currentTile.actions.push(action);\n            piece.actions.push(action);\n        }\n\n\n        // These are the diagonal capture moves\n        let diagonalCapture = [\n            {x: 1, y: direction},\n            {x: -1, y: direction}\n        ];\n        diagonalCapture.forEach(move => {\n            let currentTile = state.board.getTile(x+move.x, y+move.y);\n\n            if (currentTile !== null) {\n                let attackAction = {\n                    type: 'ATTACK_PIECE',\n                    piece: piece,\n                    tile: currentTile,\n                    action: false\n                };\n                currentTile.actions.push(attackAction);\n                piece.actions.push(attackAction);\n\n                if (currentTile.piece && currentTile.piece.player !== piece.player) {\n                    let moveAction = {\n                        type: 'MOVE_PIECE',\n                        piece: piece,\n                        tile: currentTile,\n                        action: true\n                    };\n\n                    currentTile.actions.push(moveAction);\n                    piece.actions.push(moveAction);\n                }\n            }\n        });\n    }\n}\n\nexport default MovePawnRule;","import { GameRule } from './GameRule';\n\nclass MovePawnTwoRule extends GameRule {\n\n    static atTurnStart(state) {\n        const tiles = state.board.getAllPiecesOfType('pawn');\n        tiles.forEach(this.markAllowedMoves.bind(this, state));\n\n        return state;\n    }\n\n    static markAllowedMoves(state, tile) {\n        const piece = tile.piece;\n        const direction = piece.player === 'white' ? -1 : 1;\n        const allowedRank = piece.player === 'white' ? 6 : 1;\n        const {x, y} = tile;\n\n        // Pawn is in the wrong place, so it's not eligible to move\n        if (y !== allowedRank) return;\n\n        // Check whether the pawn can move forward\n        let currentTile = state.board.getTile(x, y + direction);\n        if (currentTile.piece) return;\n\n        // Now check whether the pawn can move two forward\n        currentTile = state.board.getTile(x, y + (2 * direction));\n        if (currentTile.piece) return;\n\n        let moveAction = {\n            type: 'MOVE_PIECE',\n            piece: piece,\n            tile: currentTile,\n            action: true\n        };\n\n        currentTile.actions.push(moveAction);\n        piece.actions.push(moveAction);\n    }\n}\n\nexport default MovePawnTwoRule;","\nimport { MoveRule } from './MoveRule';\n\nclass MoveQueenRule extends MoveRule {\n    static allowedMoves = [\n        {x: 0, y: 1},\n        {x: 0, y: -1},\n        {x: 1, y: 0},\n        {x: 1, y: 1},\n        {x: 1, y: -1},\n        {x: -1, y: 0},\n        {x: -1, y: 1},\n        {x: -1, y: -1}\n    ];\n    static type = 'queen';\n    static repeat = true;\n}\n\nexport default MoveQueenRule;","\nimport { MoveRule } from './MoveRule';\n\nclass MoveRookRule extends MoveRule {\n    static allowedMoves = [\n        {x: 0, y: 1},\n        {x: 0, y: -1},\n        {x: 1, y: 0},\n        {x: -1, y: 0},\n    ];\n    static type = 'rook';\n    static repeat = true;\n}\n\nexport default MoveRookRule;","\nimport { GameRule } from './GameRule';\n\nclass CastleRule extends GameRule {\n\n    static beforeMove(state) {\n        const tiles = state.board.getAllPiecesOfType('king');\n        tiles.forEach(this.markAllowedMoves.bind(this, state));\n\n        return state;\n    }\n\n    static execute(state, action) {\n        if (action.type !== 'CASTLE') return state;\n        if (action.piece.type !== 'king') return state;\n\n        const kingFrom = state.selectedTile;\n        const kingTo = action.tile;\n\n        const rookFrom = action.rook;\n        const rookTo = action.rookTile;\n\n        kingTo.piece = action.piece;\n        kingTo.piece.tile = kingTo;\n        kingFrom.piece = null;\n\n        rookTo.piece = rookFrom.piece;\n        rookTo.piece.tile = rookTo;\n        rookFrom.piece = null;\n\n        return state;\n    }\n\n    static markAllowedMoves(state, tile) {\n        const king = tile.piece;\n        const allowedRank = king.player === 'white' ? 7 : 0;\n\n        const kingRook = state.board.getTile(7, allowedRank);\n        const queenRook = state.board.getTile(0, allowedRank);\n\n        // Check whether the king has moved\n        if (this.hasMoved(state, tile)) { return; }\n\n        // Check the kingside castle\n        this.setupCastle(state, tile, kingRook, 1);\n        this.setupCastle(state, tile, queenRook, -1);\n    }\n\n    static setupCastle(state, king, rook, direction) {\n        // Check whether our rooks are actually rooks\n        if (!rook.piece\n            || rook.piece.type !== 'rook'\n            || rook.piece.player !== king.piece.player) {\n            return false;\n        }\n\n        let canCastle = !this.hasMoved(state, rook);\n        let castleTile = state.board.getTile(king.x + 2*direction, king.y);\n\n        // Make sure there are no pieces between the king and rook\n        let castleTiles = state.board.getTilesBetween(king, rook);\n        castleTiles.forEach(tile => {\n            if (tile.piece && tile.piece !== king.piece && tile.piece !== rook.piece) {\n                canCastle = false;\n            }\n        });\n\n        // Make sure the king doesn't move through check\n        castleTiles = state.board.getTilesBetween(king, castleTile);\n        castleTiles.forEach(tile => {\n            let actions = tile.actions.filter(action => {\n                return action.type === 'ATTACK_PIECE' && action.piece.player !== king.piece.player;\n            });\n            if (actions.length) {\n                canCastle = false;\n            }\n        });\n\n        if (canCastle) {\n            let action = {\n                type: 'CASTLE',\n                piece: king.piece,\n                rook: rook,\n                rookTile: state.board.getTile(king.x + direction, king.y),\n                tile: castleTile,\n                action: true\n            };\n\n            castleTile.actions.push(action);\n            king.piece.actions.push(action);\n        }\n    }\n\n    static hasMoved(state, tile) {\n        let moved = false;\n        state.history.forEach((item) => {\n            // If a piece has moved to where the current piece is, it has moved before\n            if (item.to.x === tile.x && item.to.y === tile.y) {\n                moved = true;\n            }\n        });\n\n        return moved;\n    }\n}\n\nexport default CastleRule;","import {GameRule} from './GameRule';\n\n/**\n * When the king is in check, only allow moves which get the player out of check\n */\nclass MustBlockCheckRule extends GameRule {\n\n    static beforeMove(state) {\n        const tiles = state.board.getAllPiecesOfType('king');\n        tiles.forEach(this.pruneMoves.bind(this, state));\n\n        return state;\n    }\n\n    static pruneMoves(state, tile) {\n        let attackActions = tile.actions.filter(action => {\n            return action.type === 'ATTACK_PIECE' && action.piece.player !== tile.piece.player\n        });\n\n        attackActions.forEach(action => {\n            let attackPiece = action.piece;\n            let attackTiles = state.board.getTilesBetween(action.piece.tile, tile)\n                .filter(tile => {\n                    // We have to make sure that these tiles also contain attack actions to verify that the attack is\n                    // blockable\n                    let filterTile = action.piece.tile === attackPiece.tile;\n                    tile.actions.filter(action => action.type === 'ATTACK_PIECE')\n                        .forEach(action => {\n                            if (action.piece === attackPiece) {\n                                filterTile = true;\n                            }\n                        });\n                    return filterTile;\n                });\n\n            // If there aren't any tiles, you can always capture the piece\n            if (!attackTiles.length) attackTiles = [action.piece.tile];\n\n            let pieces = state.board.getPlayerPieces(attackPiece.player === 'white' ? 'black' : 'white')\n                .map(piece => piece.piece)\n                .filter(piece => piece.type !== 'king');\n\n            pieces.forEach(piece => {\n                // Now we need to filter the pinned piece's actions to the intersect of the attackTiles and it's own moves\n                piece.actions = piece.actions\n                    .filter(action => action.type === 'MOVE_PIECE')\n                    .filter(action => {\n                        let allowedAction = false;\n                        attackTiles.forEach((attackTile) => {\n                            if (attackTile.x === action.tile.x && attackTile.y === action.tile.y) {\n                                allowedAction = true;\n                            }\n                        });\n\n                        if (!allowedAction) {\n                            let actionIndex = action.tile.actions.indexOf(action);\n                            action.tile.actions.splice(actionIndex, 1);\n                        } else {\n                            console.log(action);\n                        }\n\n                        return allowedAction;\n                    });\n            });\n        });\n    }\n}\n\nexport default MustBlockCheckRule;","import {GameRule} from './GameRule';\n\n/**\n * Prevent a king from moving into check\n */\nclass KingMoveToCheckRule extends GameRule {\n\n    static beforeMove(state) {\n        const tiles = state.board.getAllPiecesOfType('king');\n        tiles.forEach(this.pruneMoves.bind(this, state));\n\n        return state;\n    }\n\n    static pruneMoves(state, tile) {\n        tile.piece.actions = tile.piece.actions.filter(action => {\n            if (action.type !== 'MOVE_PIECE') return true;\n\n            let allowedAction = true;\n            action.tile.actions.forEach((action) => {\n                if (action.type === 'ATTACK_PIECE' && action.piece.player !== tile.piece.player) {\n                    allowedAction = false;\n                }\n            });\n\n            if (!allowedAction) {\n                let actionIndex = action.tile.actions.indexOf(action);\n                action.tile.actions.splice(actionIndex, 1);\n            }\n\n            return allowedAction;\n        });\n    }\n}\n\nexport default KingMoveToCheckRule;","\nimport MoveBishopRule from './rules/MoveBishopRule';\nimport MoveKingRule from './rules/MoveKingRule';\nimport MoveKnightRule from './rules/MoveKnightRule';\nimport MovePawnRule from './rules/MovePawnRule';\nimport MovePawnTwoRule from './rules/MovePawnTwoRule';\nimport MoveQueenRule from './rules/MoveQueenRule';\nimport MoveRookRule from './rules/MoveRookRule';\n\nimport CastleRule from './rules/CastleRule';\nimport MustBlockCheckRule from './rules/MustBlockCheckRule';\nimport KingMoveToCheckRule from './rules/KingMoveToCheckRule';\nimport PinnedPieceCheckRule from './rules/PinnedPieceCheckRule';\n\nimport CheckmateRule from './rules/CheckmateRule';\nimport NoMoveStalemateRule from './rules/NoMoveStatelmateRule';\n\nconst GameRules = [\n    MoveBishopRule,\n    MoveKnightRule,\n    MoveKingRule,\n    MovePawnRule,\n    MovePawnTwoRule,\n    MoveQueenRule,\n    MoveRookRule,\n    CastleRule,\n    PinnedPieceCheckRule,\n    MustBlockCheckRule,\n    KingMoveToCheckRule,\n    CheckmateRule,\n    NoMoveStalemateRule\n];\n\nexport {\n    GameRules,\n    MoveBishopRule,\n    MoveKnightRule,\n    MoveKingRule,\n    MovePawnRule,\n    MovePawnTwoRule,\n    MoveQueenRule,\n    MoveRookRule,\n    CastleRule,\n    PinnedPieceCheckRule,\n    MustBlockCheckRule,\n    KingMoveToCheckRule,\n    CheckmateRule,\n    NoMoveStalemateRule\n};","import {GameRule} from './GameRule';\n\n/**\n * Stop a player from moving a piece that would put the king in check\n */\nclass PinnedPieceCheckRule extends GameRule {\n\n    static beforeMove(state) {\n        const tiles = state.board.getAllPiecesOfType('king');\n        tiles.forEach(this.pruneMoves.bind(this, state));\n\n        return state;\n    }\n\n    static pruneMoves(state, tile) {\n        let pinnedActions = tile.actions.filter(action => action.type === 'ATTACK_PINNED');\n        pinnedActions.forEach(action => {\n            let attackTiles = state.board.getTilesBetween(action.piece.tile, tile);\n\n            // Search for the piece in the attackTiles that is being pinned\n            let pinnedPiece = null;\n            attackTiles.forEach(piece => {\n                if (!piece.piece) return;\n                if (!piece.piece.player === tile.piece.player) return;\n                if (piece.x === tile.x && piece.y === tile.y) return; //exclude the current piece\n\n                pinnedPiece = piece.piece;\n            });\n\n            console.log(pinnedPiece);\n\n            // Now we need to filter the pinned piece's actions to the intersect of the attackTiles and it's own moves\n            pinnedPiece.actions = pinnedPiece.actions\n                .filter(action => action.type === 'MOVE_PIECE')\n                .filter(action => {\n                    console.log(action);\n                    let allowedAction = false;\n                    attackTiles.forEach((attackTile) => {\n                        if (attackTile.x === action.tile.x && attackTile.y === action.tile.y) {\n                            console.log(action, attackTile);\n                            allowedAction = true;\n                        }\n                    });\n\n                    if (!allowedAction) {\n                        console.log(action);\n                        let actionIndex = action.tile.actions.indexOf(action);\n                        action.tile.actions.splice(actionIndex, 1);\n                        console.log(action.tile.actions);\n                    }\n\n                    return allowedAction;\n                });\n        });\n    }\n}\n\nexport default PinnedPieceCheckRule;","\nimport { GameRule } from './GameRule';\n\nclass CheckmateRule extends GameRule {\n\n    static stateCheck(state) {\n        const tiles = state.board.getAllPiecesOfType('king');\n        tiles.forEach(this.checkForWinner.bind(this, state));\n\n        return state;\n    }\n\n    static checkForWinner(state, tile) {\n        const player = tile.piece.player;\n\n        // Check that the king is actively in check, otherwise bail\n        let inCheck = this.getAttackingPieces(tile, player).length;\n        if (!inCheck) { return state; }\n\n        // If there are no moves that would get the player out of check, the player is in checkmate\n        let pieces = state.board.getPlayerPieces(player).map(piece => piece.piece);\n        let checkmate = true;\n\n        pieces.forEach(piece => {\n            let moveActions = piece.actions.filter(action => action.type === 'MOVE_PIECE');\n            if (moveActions.length) checkmate = false;\n        });\n\n        if (checkmate) {\n            state.winner = true;\n            state.message = \"The game was won by \" + (player === 'white' ? 'black' : 'white');\n        }\n    }\n\n    static getAttackingPieces(tile, player) {\n        return tile.actions.filter(action => {\n            return action.type === 'ATTACK_PIECE' && action.piece.player !== tile.piece.player\n        })\n    }\n}\n\nexport default CheckmateRule;","\nimport { GameRule } from './GameRule';\n\nclass NoMoveStatelmateRule extends GameRule {\n\n    static stateCheck(state) {\n        const tiles = state.board.getAllPiecesOfType('king');\n        tiles.forEach(this.checkForWinner.bind(this, state));\n\n        return state;\n    }\n\n    static checkForWinner(state, tile) {\n        const player = tile.piece.player;\n\n        // Check that the king is actively in check, otherwise bail\n        let inCheck = this.getAttackingPieces(tile, player).length;\n        if (inCheck) { return state; }\n\n        // If there are no moves that would get the player out of check, the player is in checkmate\n        let pieces = state.board.getPlayerPieces(player).map(piece => piece.piece);\n        let stalemate = true;\n\n        pieces.forEach(piece => {\n            let moveActions = piece.actions.filter(action => action.type === 'MOVE_PIECE');\n            if (moveActions.length) stalemate = false;\n        });\n\n        if (stalemate) {\n            state.winner = true;\n            state.message = \"The game was a draw\";\n        }\n    }\n\n    static getAttackingPieces(tile, player) {\n        return tile.actions.filter(action => {\n            return action.type === 'ATTACK_PIECE' && action.piece.player !== tile.piece.player\n        })\n    }\n}\n\nexport default NoMoveStatelmateRule;","import { createStore } from 'redux';\n\nimport { Board } from './board';\nimport { GameRules } from './rules';\n\nconst board = `\n    BR,BN,BB,BQ,BK,BB,BN,BR;\n    BP,BP,BP,BP,BP,BP,BP,BP;\n    ,,,,,,,;\n    ,,,,,,,;\n    ,,,,,,,;\n    ,,,,,,,;\n    WP,WP,WP,WP,WP,WP,WP,WP;\n    WR,WN,WB,WQ,WK,WB,WN,WR;\n    `;\n\nconst defaultState = {\n    winner: false,\n    message: '',\n    player: 'white',\n    selectedTile: null,\n    board: Board.parseBoard(board),\n    history: []\n};\n\nconst store = createStore(function (state = defaultState, action) {\n    if (state.winner && action.type !== 'RESET_GAME') {\n        return state;\n    }\n\n    state = Object.assign({}, state);\n\n    switch (action.type) {\n        case 'SELECT_PIECE':\n            state = Object.assign(state, {\n                selectedTile: action.tile\n            });\n            return state;\n        case 'RESET_GAME':\n            return defaultState;\n        default:\n            // Default action is to forward the action to game rules and let them\n            // decide whether to act on an action\n            state.board = new Board(state.board);\n\n            // Execute the action\n            GameRules.forEach(rule => state = rule.execute(state, action));\n\n            if (action.tile && action.action) {\n                state.history.push({\n                    from: {x: state.selectedTile.x, y: state.selectedTile.y},\n                    to: {x: action.tile.x, y: action.tile.y}\n                });\n            }\n\n            // Start the next turn\n            if (action.type.indexOf('@@redux') < 0) {\n                state.player = state.player === 'white' ? 'black' : 'white';\n            }\n            state.board.clearState();\n            state.selectedTile = null;\n\n            GameRules.forEach(rule => state = rule.atTurnStart(state));\n            GameRules.forEach(rule => state = rule.beforeMove(state));\n            GameRules.forEach(rule => state = rule.stateCheck(state));\n            state.board = state.board.toStore();\n            return state;\n    }\n});\n\nexport default store;","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nimport '../styles/Piece.css';\n\nclass Tile extends Component {\n\n  static parsePlayer(token) {\n    if (typeof(token) !== 'string' && token.length !== 2) { return null; }\n\n    switch(token.charAt(0)) {\n        case 'B':\n          return 'black';\n        case 'W':\n          return 'white';\n        default:\n          return null;\n    }\n  }\n\n  static parsePiece(token) {\n      if (typeof(token) !== 'string' && token.length !== 2) { return null; }\n\n      switch(token.charAt(1)) {\n          case 'K':\n              return 'king';\n          case 'Q':\n              return 'queen';\n          case 'B':\n              return 'bishop';\n          case 'R':\n              return 'rook';\n          case 'N':\n              return 'knight';\n          case 'P':\n              return 'pawn';\n          default:\n              return null;\n      }\n  }\n\n  getPiece() {\n      let piece = this.props.tile.piece;\n      let player = piece ? piece.player : '';\n\n      return player && piece ? `${player} ${piece.type}` : '';\n  }\n\n    /**\n     * Check whether this tile is the target of an action from the selected piece\n     * @returns {boolean}\n     */\n  isLegal() {\n      if (!this.props.selectedTile || !this.props.selectedTile.piece) { return false; }\n      let piece = this.props.selectedTile.piece;\n      let legal = false;\n\n        // Filter out actions on this tile that don't involve the correct piece\n        let actions = piece.actions.filter(action => {\n            return action.tile === this.props.tile && action.action === true\n        });\n\n        actions.forEach((action) => {\n            if (action.tile.x === this.props.tile.x && action.tile.y === this.props.tile.y) {\n                legal = true;\n            }\n        });\n\n        return legal;\n  }\n\n  handleClick() {\n      let selectedTile = this.props.selectedTile;\n      if (selectedTile\n          && selectedTile.piece\n          && selectedTile.piece.player === this.props.player) {\n\n          // Filter out actions on this tile that don't involve the correct piece\n          let actions = this.props.tile.actions.filter(action => {\n              return action.piece === selectedTile.piece && action.type !== 'ATTACK_PIECE'\n          });\n\n          actions.forEach((action) => {\n              this.props.dispatch(action)\n          });\n\n          if (actions.length) return;\n      }\n\n      this.props.dispatch({\n          type: 'SELECT_PIECE',\n          tile: this.props.tile\n      })\n  }\n\n  render() {\n      let legal = this.isLegal();\n      let selected = false;\n      if (this.props.selectedTile) {\n          selected = this.props.selectedTile.x === this.props.tile.x && this.props.selectedTile.y === this.props.tile.y;\n      }\n\n    return (\n      <div id={this.props.id}\n           data-x={this.props.tile.x}\n           data-y={this.props.tile.y}\n           className={`tile ${this.getPiece()} ${selected ? 'selected' : ''} ${legal ? 'legal' : ''}`}\n           onClick={this.handleClick.bind(this)} />\n    );\n  }\n}\n\nfunction stateMap(state) {\n    return {\n        player: state.player,\n        selectedTile: state.selectedTile\n    };\n}\n\nexport default connect(stateMap)(Tile);\n","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nimport Tile from './Tile';\nimport '../styles/Board.css';\n\nclass Board extends Component {\n\n    drawBoard() {\n        //Iterate over A->H to identify tiles (using ASCII char codes)\n        let charCode = 'A'.charCodeAt(0);\n        return this.props.board.map((row) => {\n            let output = [];\n            let counter = 0;\n\n            let tiles = row.map((tile) => {\n                let key = String.fromCharCode(charCode) + counter;\n                counter += 1;\n\n                return <Tile id={key} key={key} tile={tile} />;\n            });\n\n            output.push(<div key={String.fromCharCode(charCode)} className=\"row\">{tiles}</div>);\n\n            charCode += 1;\n            return output;\n        });\n    }\n\n    static parseRowCol(token) {\n        let row = token.charCodeAt(0) - 'A'.charCodeAt(0);\n        let col = parseInt(token.charAt(1));\n\n        return {row, col};\n    }\n\n    render() {\n        return (\n            <div className={`board ${this.props.player} ${this.props.history.length ? 'playing': ''}`}>\n                {this.props.winner ? this.props.message : ''}\n                {this.drawBoard.apply(this)}\n            </div>\n        )\n\n    }\n}\n\nfunction mapStateToProps(state) {\n    return {\n        winner: state.winner,\n        message: state.message,\n        player: state.player,\n        selectedTile: state.selectedTile,\n        board: state.board,\n        history: state.history\n    }\n}\n\nexport default connect(mapStateToProps)(Board);","import React, { Component } from 'react';\nimport { Provider } from 'react-redux';\n\nimport store from '../data/store';\nimport Board from './Board';\nimport '../styles/App.css';\n\nclass App extends Component {\n  // constructor(props) {\n  //   super(props);\n  //\n  //   /* Set up the inital board state -- B / W for Black and White\n  //    * K = King, Q = Queen, B = Bishop, N = Knight, R = Rook, P = Pawn\n  //    */\n  //   let board = `\n  //   BR,BN,BB,BQ,BK,BB,BN,BR;\n  //   BP,BP,BP,BP,BP,BP,BP,BP;\n  //   ,,,,,,,;\n  //   ,,,,,,,;\n  //   ,,,,,,,;\n  //   ,,,,,,,;\n  //   WP,WP,WP,WP,WP,WP,WP,WP;\n  //   WR,WN,WB,WQ,WK,WB,WN,WR;\n  //   `;\n  //\n  //   this.state = {board: this.parseBoard(board)}\n  // }\n  //\n  // parseBoard(board) {\n  //   let parsedBoard = [];\n  //\n  //   let rows = board.split(';');\n  //   rows.splice(rows.length-1, 1); //the final ; creates an off-by-one error, so remove the last element\n  //\n  //   //Split the rows, and trim the results\n  //   rows.forEach(function(row) {\n  //     let tiles = row.split(',');\n  //     tiles = tiles.map((tile) => tile.trim());\n  //\n  //     parsedBoard.push(tiles)\n  //   });\n  //\n  //   return parsedBoard;\n  // }\n\n  render() {\n    return (\n      <Provider store={store}>\n        <div className=\"App\">\n          <Board />\n        </div>\n      </Provider>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}