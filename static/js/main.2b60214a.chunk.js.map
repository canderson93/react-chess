{"version":3,"sources":["data/board.js","data/rules/GameRule.js","data/rules/MoveRule.js","data/rules/MoveBishopRule.js","data/rules/MoveKingRule.js","data/rules/MoveKnightRule.js","data/rules/MovePawnRule.js","data/rules/MovePawnTwoRule.js","data/rules/MoveQueenRule.js","data/rules/MoveRookRule.js","data/rules.js","data/rules/CastleRule.js","data/store.js","components/Tile.js","components/Board.js","components/App.js","serviceWorker.js","index.js"],"names":["Board","board","Object","classCallCheck","this","x","y","length","from","to","xDirection","yDirection","Math","abs","tiles","push","getTile","piece","pieces","forEach","row","tile","type","actions","_this","parsedBoard","rows","split","splice","yIndex","map","xIndex","token","trim","player","parsePlayer","parsePiece","charAt","GameRule","state","action","MoveRule","getAllPiecesOfType","markAllowedMoves","bind","selectedTile","allowedMoves","move","currentTile","attackAction","moveAction","repeat","MoveBishopRule","MoveKingRule","MoveKnightRule","MovePawnRule","direction","MovePawnTwoRule","allowedRank","MoveQueenRule","MoveRookRule","GameRules","kingFrom","kingTo","rookFrom","rook","rookTo","rookTile","kingRook","queenRook","hasMoved","setupCastle","king","canCastle","castleTile","castleTiles","getTilesBetween","filter","moved","history","item","defaultState","winner","rejected","parseBoard","store","createStore","arguments","undefined","oldState","assign","console","log","rule","execute","afterMove","indexOf","clearState","atTurnStart","beforeMove","toStore","Tile","props","possibleConstructorReturn","getPrototypeOf","call","concat","legal","_this2","dispatch","isLegal","selected","react_default","a","createElement","id","data-x","data-y","className","getPiece","onClick","handleClick","Component","connect","charCode","charCodeAt","output","counter","key","String","fromCharCode","components_Tile","drawBoard","apply","col","parseInt","App","es","components_Board","Boolean","window","location","hostname","match","ReactDOM","render","components_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"sTACMA,aAGF,SAAAA,EAAYC,GAAQC,OAAAC,EAAA,EAAAD,CAAAE,KAAAJ,GAAAI,KAFpBH,MAAQ,GAGJG,KAAKH,MAAQA,sDASTI,EAAGC,GACP,OAAIA,EAAI,GAAKA,GAAKF,KAAKH,MAAMM,OAAiB,KAC1CF,EAAI,GAAKA,GAAKD,KAAKH,MAAM,GAAGM,OAAiB,KAE1CH,KAAKH,MAAMK,GAAGD,2CAGTG,EAAMC,GAClB,IAAIJ,EAAIG,EAAKH,EACTC,EAAIE,EAAKF,EAETI,EAAaD,EAAGJ,EAAIG,EAAKH,EACzBM,EAAaF,EAAGH,EAAIE,EAAKF,EAG7B,GAAIM,KAAKC,IAAIH,KAAgBE,KAAKC,IAAIF,IAA8B,IAAfD,GAAmC,IAAfC,EACrE,MAAO,GAGX,IAAMG,EAAQ,GAMd,IAHAJ,EAAaA,EAAaE,KAAKC,IAAIH,IAAeA,EAClDC,EAAaA,EAAaC,KAAKC,IAAIF,IAAeA,EAE3CN,IAAMI,EAAGJ,GAAKC,IAAMG,EAAGH,GAC1BQ,EAAMC,KAAKX,KAAKY,QAAQX,EAAGC,IAE3BD,GAAKK,EACLJ,GAAKK,EAGT,OAAOG,6CAGQG,GACf,IAAMC,EAAS,GAUf,OARAd,KAAKH,MAAMkB,QAAQ,SAAAC,GACfA,EAAID,QAAQ,SAAAE,GACJA,EAAKJ,OAASI,EAAKJ,MAAMK,OAASL,GAClCC,EAAOH,KAAKM,OAKjBH,uCAIPd,KAAKH,MAAMkB,QAAQ,SAAAC,GACfA,EAAID,QAAQ,SAAAE,GACRA,EAAKE,QAAU,GAEXF,EAAKJ,QACLI,EAAKJ,MAAMM,QAAU,0CAOjC,OAAOnB,KAAKH,2CAGEA,GAAO,IAAAuB,EAAApB,KACjBqB,EAAc,GAEdC,EAAOzB,EAAM0B,MAAM,KA0BvB,OAzBAD,EAAKE,OAAOF,EAAKnB,OAAS,EAAG,GAG7BmB,EAAKP,QAAQ,SAACC,EAAKS,GACf,IAAIf,EAAQM,EAAIO,MAAM,KACtBb,EAAQA,EAAMgB,IAAI,SAACT,EAAMU,GACrB,IAAIC,EAAQX,EAAKY,OACbhB,EAAQ,KAQZ,OAPIe,IACAf,EAAQ,CACJiB,OAAQV,EAAKW,YAAYH,GACzBV,KAAME,EAAKY,WAAWJ,KAIvB,CACH3B,EAAG0B,EACHzB,EAAGuB,EACHZ,MAAOA,KAIfQ,EAAYV,KAAKD,KAGdW,sCAIQO,GACf,GAAsB,kBAAXA,GAAwC,IAAjBA,EAAMzB,OACpC,OAAO,KAGX,OAAQyB,EAAMK,OAAO,IACjB,IAAK,IACD,MAAO,QACX,IAAK,IACD,MAAO,QACX,QACI,OAAO,yCAIDL,GACd,GAAsB,kBAAXA,GAAwC,IAAjBA,EAAMzB,OACpC,OAAO,KAGX,OAAQyB,EAAMK,OAAO,IACjB,IAAK,IACD,MAAO,OACX,IAAK,IACD,MAAO,QACX,IAAK,IACD,MAAO,SACX,IAAK,IACD,MAAO,OACX,IAAK,IACD,MAAO,SACX,IAAK,IACD,MAAO,OACX,QACI,OAAO,eCjJjBC,2GASiBC,GAAQ,OAAOA,qCAQhBA,GAAQ,OAAOA,kCASlBA,EAAOC,GAAS,OAAOD,oCAQrBA,GAAQ,OAAOA,WChC9BE,2LAKiBF,GAIf,OAHcA,EAAMtC,MAAMyC,mBAAmBtC,KAAKkB,MAC5CH,QAAQf,KAAKuC,iBAAiBC,KAAKxC,KAAMmC,IAExCA,kCAGIA,EAAOC,GAClB,GAAoB,eAAhBA,EAAOlB,KAAuB,OAAOiB,EACzC,GAAIC,EAAOvB,MAAMK,OAASlB,KAAKkB,KAAM,OAAOiB,EAE5C,IAAM/B,EAAO+B,EAAMM,aACbpC,EAAK+B,EAAOnB,KAKlB,OAHAb,EAAKS,MAAQ,KACbR,EAAGQ,MAAQuB,EAAOvB,MAEXsB,2CAGaA,EAAOlB,GAAM,IAAAG,EAAApB,KAC3Ba,EAAQI,EAAKJ,MAEnBb,KAAK0C,aAAa3B,QAAQ,SAAA4B,GAAQ,IACzB1C,EAAQgB,EAARhB,EAAGC,EAAKe,EAALf,EAERD,GAAK0C,EAAK1C,EACVC,GAAKyC,EAAKzC,EAGV,IAFA,IAAI0C,EAAcT,EAAMtC,MAAMe,QAAQX,EAAGC,GAElB,OAAhB0C,GAAsB,CACzB,IAAIC,EAAe,CACf3B,KAAM,eACNL,MAAOA,EACPI,KAAM2B,GAKV,GAHAA,EAAYzB,QAAQR,KAAKkC,GACzBhC,EAAMM,QAAQR,KAAKkC,GAEfD,EAAY/B,OAAS+B,EAAY/B,MAAMiB,SAAWjB,EAAMiB,OAAQ,MAEpE,IAAIgB,EAAa,CACb5B,KAAM,aACNL,MAAOA,EACPI,KAAM2B,GAMV,GAHAA,EAAYzB,QAAQR,KAAKmC,GACzBjC,EAAMM,QAAQR,KAAKmC,GAEfF,EAAY/B,OAAS+B,EAAY/B,MAAMiB,SAAWjB,EAAMiB,OAAQ,MACpE,IAAKV,EAAK2B,OAAQ,MAElB9C,GAAK0C,EAAK1C,EACVC,GAAKyC,EAAKzC,EACV0C,EAAcT,EAAMtC,MAAMe,QAAQX,EAAGC,aA5D9BgC,GAAjBG,EACKK,aAAe,GADpBL,EAEKnB,KAAO,GAFZmB,EAGKU,QAAS,MCHdC,wIAAuBX,GAAvBW,EACKN,aAAe,CAClB,CAACzC,EAAG,EAAGC,EAAG,GACV,CAACD,EAAG,EAAGC,GAAI,GACX,CAACD,GAAI,EAAGC,EAAG,GACX,CAACD,GAAI,EAAGC,GAAI,IALd8C,EAOK9B,KAAO,SAPZ8B,EAQKD,QAAS,EAGLC,QCXTC,wIAAqBZ,GAArBY,EACKP,aAAe,CAClB,CAACzC,EAAG,EAAGC,EAAG,GACV,CAACD,EAAG,EAAGC,GAAI,GACX,CAACD,EAAG,EAAGC,EAAG,GACV,CAACD,EAAG,EAAGC,EAAG,GACV,CAACD,EAAG,EAAGC,GAAI,GACX,CAACD,GAAI,EAAGC,EAAG,GACX,CAACD,GAAI,EAAGC,EAAG,GACX,CAACD,GAAI,EAAGC,GAAI,IATd+C,EAWK/B,KAAO,OAXZ+B,EAYKF,QAAS,EAGLE,QCfTC,wIAAuBb,GAAvBa,EACKR,aAAe,CAClB,CAACzC,EAAG,EAAGC,EAAG,GACV,CAACD,EAAG,EAAGC,GAAI,GACX,CAACD,GAAI,EAAGC,EAAG,GACX,CAACD,GAAI,EAAGC,GAAI,GACZ,CAACD,EAAG,EAAGC,EAAG,GACV,CAACD,EAAG,EAAGC,GAAI,GACX,CAACD,GAAI,EAAGC,EAAG,GACX,CAACD,GAAI,EAAGC,GAAI,IATdgD,EAWKhC,KAAO,SAXZgC,EAYKH,QAAS,EAGLG,QCfTC,gMAIsBhB,EAAOlB,GAC3B,IAAMJ,EAAQI,EAAKJ,MACbuC,EAA6B,UAAjBvC,EAAMiB,QAAsB,EAAI,EAC3C7B,EAAQgB,EAARhB,EAAGC,EAAKe,EAALf,EAGN0C,EAAcT,EAAMtC,MAAMe,QAAQX,EAAGC,EAAIkD,GAC7C,GAAIR,IAAgBA,EAAY/B,MAAO,CACnC,IAAIuB,EAAS,CACTlB,KAAM,aACNL,MAAOA,EACPI,KAAM2B,GAEVA,EAAYzB,QAAQR,KAAKyB,GACzBvB,EAAMM,QAAQR,KAAKyB,GAKD,CAClB,CAACnC,EAAG,EAAGC,EAAGkD,GACV,CAACnD,GAAI,EAAGC,EAAGkD,IAECrC,QAAQ,SAAA4B,GACpB,IAAIC,EAAcT,EAAMtC,MAAMe,QAAQX,EAAE0C,EAAK1C,EAAGC,EAAEyC,EAAKzC,GAEvD,GAAoB,OAAhB0C,EAAsB,CACtB,IAAIC,EAAe,CACf3B,KAAM,eACNL,MAAOA,EACPI,KAAM2B,GAKV,GAHAA,EAAYzB,QAAQR,KAAKkC,GACzBhC,EAAMM,QAAQR,KAAKkC,GAEfD,EAAY/B,OAAS+B,EAAY/B,MAAMiB,SAAWjB,EAAMiB,OAAQ,CAChE,IAAIgB,EAAa,CACb5B,KAAM,aACNL,MAAOA,EACPI,KAAM2B,GAGVA,EAAYzB,QAAQR,KAAKmC,GACzBjC,EAAMM,QAAQR,KAAKmC,cA/CZT,GAArBc,EACKjC,KAAO,OADZiC,EAEKJ,QAAS,EAoDLI,QClBAE,2LAnCQlB,GAIf,OAHcA,EAAMtC,MAAMyC,mBAAmB,QACvCvB,QAAQf,KAAKuC,iBAAiBC,KAAKxC,KAAMmC,IAExCA,2CAGaA,EAAOlB,GAC3B,IAAMJ,EAAQI,EAAKJ,MACbuC,EAA6B,UAAjBvC,EAAMiB,QAAsB,EAAI,EAC5CwB,EAA+B,UAAjBzC,EAAMiB,OAAqB,EAAI,EAC5C7B,EAAQgB,EAARhB,EAAGC,EAAKe,EAALf,EAGV,GAAIA,IAAMoD,EAAV,CAGA,IAAIV,EAAcT,EAAMtC,MAAMe,QAAQX,EAAGC,EAAIkD,GAC7C,IAAIR,EAAY/B,SAGhB+B,EAAcT,EAAMtC,MAAMe,QAAQX,EAAGC,EAAK,EAAIkD,IAC9BvC,MAAhB,CAEA,IAAIiC,EAAa,CACb5B,KAAM,aACNL,MAAOA,EACPI,KAAM2B,GAGVA,EAAYzB,QAAQR,KAAKmC,GACzBjC,EAAMM,QAAQR,KAAKmC,YAjCGZ,GCCxBqB,wIAAsBlB,GAAtBkB,EACKb,aAAe,CAClB,CAACzC,EAAG,EAAGC,EAAG,GACV,CAACD,EAAG,EAAGC,GAAI,GACX,CAACD,EAAG,EAAGC,EAAG,GACV,CAACD,EAAG,EAAGC,EAAG,GACV,CAACD,EAAG,EAAGC,GAAI,GACX,CAACD,GAAI,EAAGC,EAAG,GACX,CAACD,GAAI,EAAGC,EAAG,GACX,CAACD,GAAI,EAAGC,GAAI,IATdqD,EAWKrC,KAAO,QAXZqC,EAYKR,QAAS,EAGLQ,QCfTC,wIAAqBnB,GAArBmB,EACKd,aAAe,CAClB,CAACzC,EAAG,EAAGC,EAAG,GACV,CAACD,EAAG,EAAGC,GAAI,GACX,CAACD,EAAG,EAAGC,EAAG,GACV,CAACD,GAAI,EAAGC,EAAG,IALbsD,EAOKtC,KAAO,OAPZsC,EAQKT,QAAS,EAGLS,ICHTC,EAAY,CACdT,EACAE,EACAD,EACAE,EACAE,EACAE,EDHWC,0LETOrB,GAId,OAHcA,EAAMtC,MAAMyC,mBAAmB,QACvCvB,QAAQf,KAAKuC,iBAAiBC,KAAKxC,KAAMmC,IAExCA,kCAGIA,EAAOC,GAClB,GAAoB,WAAhBA,EAAOlB,KAAmB,OAAOiB,EACrC,GAA0B,SAAtBC,EAAOvB,MAAMK,KAAiB,OAAOiB,EAEzC,IAAMuB,EAAWvB,EAAMM,aACjBkB,EAASvB,EAAOnB,KAEhB2C,EAAWxB,EAAOyB,KAClBC,EAAS1B,EAAO2B,SAQtB,OANAJ,EAAO9C,MAAQuB,EAAOvB,MACtB6C,EAAS7C,MAAQ,KAEjBiD,EAAOjD,MAAQ+C,EAAS/C,MACxB+C,EAAS/C,MAAQ,KAEVsB,2CAGaA,EAAOlB,GAC3B,IACMqC,EAA8B,UADvBrC,EAAKJ,MACOiB,OAAqB,EAAI,EAE5CkC,EAAW7B,EAAMtC,MAAMe,QAAQ,EAAG0C,GAClCW,EAAY9B,EAAMtC,MAAMe,QAAQ,EAAG0C,GAGrCtD,KAAKkE,SAAS/B,EAAOlB,KAGzBjB,KAAKmE,YAAYhC,EAAOlB,EAAM+C,EAAU,GACxChE,KAAKmE,YAAYhC,EAAOlB,EAAMgD,GAAY,wCAG3B9B,EAAOiC,EAAMP,EAAMT,GAElC,IAAKS,EAAKhD,OACiB,SAApBgD,EAAKhD,MAAMK,MACX2C,EAAKhD,MAAMiB,SAAWsC,EAAKvD,MAAMiB,OACpC,OAAO,EAGX,IAAIuC,GAAarE,KAAKkE,SAAS/B,EAAO0B,GAClCS,EAAanC,EAAMtC,MAAMe,QAAQwD,EAAKnE,EAAI,EAAEmD,EAAWgB,EAAKlE,GAG5DqE,EAAcpC,EAAMtC,MAAM2E,gBAAgBJ,EAAMP,GAkBpD,GAjBAU,EAAYxD,QAAQ,SAAAE,GACZA,EAAKJ,OAASI,EAAKJ,QAAUuD,EAAKvD,OAASI,EAAKJ,QAAUgD,EAAKhD,QAC/DwD,GAAY,MAKpBE,EAAcpC,EAAMtC,MAAM2E,gBAAgBJ,EAAME,IACpCvD,QAAQ,SAAAE,GACFA,EAAKE,QAAQsD,OAAO,SAAArC,GAC9B,MAAuB,iBAAhBA,EAAOlB,MAA2BkB,EAAOvB,MAAMiB,SAAWsC,EAAKvD,MAAMiB,SAEpE3B,SACRkE,GAAY,KAIhBA,EAAW,CACX,IAAIjC,EAAS,CACTlB,KAAM,SACNL,MAAOuD,EAAKvD,MACZgD,KAAMA,EACNE,SAAU5B,EAAMtC,MAAMe,QAAQwD,EAAKnE,EAAImD,EAAWgB,EAAKlE,GACvDe,KAAMqD,GAGVA,EAAWnD,QAAQR,KAAKyB,GACxBgC,EAAKvD,MAAMM,QAAQR,KAAKyB,qCAIhBD,EAAOlB,GACnB,IAAIyD,GAAQ,EAQZ,OAPAvC,EAAMwC,QAAQ5D,QAAQ,SAAC6D,GAEfA,EAAKvE,GAAGJ,IAAMgB,EAAKhB,GAAK2E,EAAKvE,GAAGH,IAAMe,EAAKf,IAC3CwE,GAAQ,KAITA,SAhGUxC,ICanB2C,EAAe,CACjBC,QAAQ,EACRC,UAAU,EACVjD,OAAQ,QACRW,aAAc,KACd5C,MAAOD,EAAMoF,WAhBN,0LAiBPL,QAAS,IA0DEM,EAvDDC,YAAY,WAAwC,IAA9B/C,EAA8BgD,UAAAhF,OAAA,QAAAiF,IAAAD,UAAA,GAAAA,UAAA,GAAtBN,EAAczC,EAAQ+C,UAAAhF,OAAA,EAAAgF,UAAA,QAAAC,EAC9D,GAAIjD,EAAM2C,QAA0B,eAAhB1C,EAAOlB,KACvB,OAAOiB,EAGX,IAAIkD,EAAWlD,EAKf,OAJAA,EAAQrC,OAAOwF,OAAO,GAAInD,GAE1BoD,QAAQC,IAAIrD,GACZoD,QAAQC,IAAIpD,GACJA,EAAOlB,MACX,IAAK,eAID,OAHAiB,EAAQrC,OAAOwF,OAAOnD,EAAO,CACzBM,aAAcL,EAAOnB,OAG7B,IAAK,aACD,OAAO4D,EACX,QAWI,OARA1C,EAAMtC,MAAQ,IAAID,EAAMuC,EAAMtC,OAG9B4D,EAAU1C,QAAQ,SAAA0E,GAAI,OAAItD,EAAQsD,EAAKC,QAAQvD,EAAOC,KACtDqB,EAAU1C,QAAQ,SAAA0E,GAAI,OAAItD,EAAQsD,EAAKE,UAAUxD,KAI7CA,EAAM4C,SACCM,GAGPjD,EAAOnB,MACPkB,EAAMwC,QAAQhE,KAAK,CACfP,KAAM,CAACH,EAAGkC,EAAMM,aAAaxC,EAAGC,EAAGiC,EAAMM,aAAavC,GACtDG,GAAI,CAACJ,EAAGmC,EAAOnB,KAAKhB,EAAGC,EAAGkC,EAAOnB,KAAKf,KAK1CkC,EAAOlB,KAAK0E,QAAQ,WAAa,IACjCzD,EAAML,OAA0B,UAAjBK,EAAML,OAAqB,QAAU,SAExDK,EAAMtC,MAAMgG,aACZ1D,EAAMM,aAAe,KAErBgB,EAAU1C,QAAQ,SAAA0E,GAAI,OAAItD,EAAQsD,EAAKK,YAAY3D,KACnDsB,EAAU1C,QAAQ,SAAA0E,GAAI,OAAItD,EAAQsD,EAAKM,WAAW5D,KAElDA,EAAMtC,MAAQsC,EAAMtC,MAAMmG,UACnB7D,MCvEb8D,qBACJ,SAAAA,EAAYC,GAAQ,OAAApG,OAAAC,EAAA,EAAAD,CAAAE,KAAAiG,GAAAnG,OAAAqG,EAAA,EAAArG,CAAAE,KAAAF,OAAAsG,EAAA,EAAAtG,CAAAmG,GAAAI,KAAArG,KACZkG,4EAsCJ,IAAIrF,EAAQb,KAAKkG,MAAMjF,KAAKJ,MACxBiB,EAASjB,EAAQA,EAAMiB,OAAS,GAEpC,OAAOA,GAAUjB,EAAV,GAAAyF,OAAqBxE,EAArB,KAAAwE,OAA+BzF,EAAMK,MAAS,qCAO/C,IAAAE,EAAApB,KACN,IAAKA,KAAKkG,MAAMzD,eAAiBzC,KAAKkG,MAAMzD,aAAa5B,MAAS,OAAO,EACzE,IAAIA,EAAQb,KAAKkG,MAAMzD,aAAa5B,MAChC0F,GAAQ,EAaV,OAVc1F,EAAMM,QAAQsD,OAAO,SAAArC,GAC/B,OAAOA,EAAOnB,OAASG,EAAK8E,MAAMjF,MAAwB,iBAAhBmB,EAAOlB,OAG7CH,QAAQ,SAACqB,GACTA,EAAOnB,KAAKhB,IAAMmB,EAAK8E,MAAMjF,KAAKhB,GAAKmC,EAAOnB,KAAKf,IAAMkB,EAAK8E,MAAMjF,KAAKf,IACzEqG,GAAQ,KAITA,wCAGC,IAAAC,EAAAxG,KACNyC,EAAezC,KAAKkG,MAAMzD,aAC9B,GAAIA,GACGA,EAAa5B,OACb4B,EAAa5B,MAAMiB,SAAW9B,KAAKkG,MAAMpE,OAAQ,CAGpD,IAAIX,EAAUnB,KAAKkG,MAAMjF,KAAKE,QAAQsD,OAAO,SAAArC,GACzC,OAAOA,EAAOvB,QAAU4B,EAAa5B,OAAyB,iBAAhBuB,EAAOlB,OASzD,GANAqE,QAAQC,IAAIxF,KAAKkG,MAAMjF,KAAKE,SAC5BoE,QAAQC,IAAIrE,GACZA,EAAQJ,QAAQ,SAACqB,GACboE,EAAKN,MAAMO,SAASrE,KAGpBjB,EAAQhB,OAAQ,OAGxBH,KAAKkG,MAAMO,SAAS,CAChBvF,KAAM,eACND,KAAMjB,KAAKkG,MAAMjF,wCAKrB,IAAIsF,EAAQvG,KAAK0G,UACbC,GAAW,EAKjB,OAJM3G,KAAKkG,MAAMzD,eACXkE,EAAW3G,KAAKkG,MAAMzD,aAAaxC,IAAMD,KAAKkG,MAAMjF,KAAKhB,GAAKD,KAAKkG,MAAMzD,aAAavC,IAAMF,KAAKkG,MAAMjF,KAAKf,GAIhH0G,EAAAC,EAAAC,cAAA,OAAKC,GAAI/G,KAAKkG,MAAMa,GACfC,SAAQhH,KAAKkG,MAAMjF,KAAKhB,EACxBgH,SAAQjH,KAAKkG,MAAMjF,KAAKf,EACxBgH,UAAS,QAAAZ,OAAUtG,KAAKmH,WAAf,KAAAb,OAA6BK,EAAW,WAAa,GAArD,KAAAL,OAA2DC,EAAQ,QAAU,IACtFa,QAASpH,KAAKqH,YAAY7E,KAAKxC,8CAtGrB4B,GACjB,GAAsB,kBAAXA,GAAwC,IAAjBA,EAAMzB,OAAgB,OAAO,KAE/D,OAAOyB,EAAMK,OAAO,IAChB,IAAK,IACH,MAAO,QACT,IAAK,IACH,MAAO,QACT,QACE,OAAO,yCAIGL,GACd,GAAsB,kBAAXA,GAAwC,IAAjBA,EAAMzB,OAAgB,OAAO,KAE/D,OAAOyB,EAAMK,OAAO,IAChB,IAAK,IACD,MAAO,OACX,IAAK,IACD,MAAO,QACX,IAAK,IACD,MAAO,SACX,IAAK,IACD,MAAO,OACX,IAAK,IACD,MAAO,SACX,IAAK,IACD,MAAO,OACX,QACI,OAAO,aAnCFqF,cAuHJC,kBAPf,SAAkBpF,GACd,MAAO,CACHL,OAAQK,EAAML,OACdW,aAAcN,EAAMM,eAIb8E,CAAkBtB,GCtH3BrG,6LAaE,IAAI4H,EAAW,IAAIC,WAAW,GAC9B,OAAOzH,KAAKkG,MAAMrG,MAAM6B,IAAI,SAACV,GACzB,IAAI0G,EAAS,GACTC,EAAU,EAEVjH,EAAQM,EAAIU,IAAI,SAACT,GACjB,IAAI2G,EAAMC,OAAOC,aAAaN,GAAYG,EAG1C,OAFAA,GAAW,EAEJf,EAAAC,EAAAC,cAACiB,EAAD,CAAMhB,GAAIa,EAAKA,IAAKA,EAAK3G,KAAMA,MAM1C,OAHAyG,EAAO/G,KAAKiG,EAAAC,EAAAC,cAAA,OAAKc,IAAKC,OAAOC,aAAaN,GAAWN,UAAU,OAAOxG,IAEtE8G,GAAY,EACLE,qCAaX,OADAnC,QAAQC,IAAIxF,KAAKkG,OAEbU,EAAAC,EAAAC,cAAA,OAAKI,UAAS,SACTlH,KAAKgI,UAAUC,MAAMjI,6CAXf4B,GAIf,MAAO,CAACZ,IAHEY,EAAM6F,WAAW,GAAK,IAAIA,WAAW,GAGlCS,IAFHC,SAASvG,EAAMK,OAAO,YAlCpBqF,cAyDLC,kBAPf,SAAyBpF,GACrB,MAAO,CACHM,aAAcN,EAAMM,aACpB5C,MAAOsC,EAAMtC,QAIN0H,CAAyB3H,GCPzBwI,0LAVX,OACExB,EAAAC,EAAAC,cAACuB,EAAA,EAAD,CAAUpD,MAAOA,GACf2B,EAAAC,EAAAC,cAAA,OAAKI,UAAU,OACbN,EAAAC,EAAAC,cAACwB,EAAD,eA1CQhB,cCKEiB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCXNC,IAASC,OAAOjC,EAAAC,EAAAC,cAACgC,EAAD,MAASC,SAASC,eAAe,SD0H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.2b60214a.chunk.js","sourcesContent":["\nclass Board {\n    board = [];\n\n    constructor(board) {\n        this.board = board;\n    }\n\n    /**\n     * Gets the tile at the x, y position on the board\n     * @param x\n     * @param y\n     * @returns {*}\n     */\n    getTile(x, y) {\n        if (y < 0 || y >= this.board.length) { return null; }\n        if (x < 0 || x >= this.board[0].length) { return null; }\n\n        return this.board[y][x];\n    }\n\n    getTilesBetween(from, to) {\n        let x = from.x;\n        let y = from.y;\n\n        let xDirection = to.x - from.x;\n        let yDirection = to.y - from.y;\n\n        // We can only move along compass points, or diagonals\n        if (Math.abs(xDirection) !== Math.abs(yDirection) && xDirection !== 0 && yDirection !== 0)\n            return [];\n\n\n        const tiles = [];\n\n        // Normalise the direction so it's either 0, 1 or -1\n        xDirection = xDirection / Math.abs(xDirection) || xDirection;\n        yDirection = yDirection / Math.abs(yDirection) || yDirection;\n\n        while (x !== to.x || y !== to.y) {\n            tiles.push(this.getTile(x, y));\n\n            x += xDirection;\n            y += yDirection;\n        }\n\n        return tiles;\n    }\n\n    getAllPiecesOfType(piece) {\n        const pieces = [];\n\n        this.board.forEach(row => {\n            row.forEach(tile => {\n                if (tile.piece && tile.piece.type === piece) {\n                    pieces.push(tile);\n                }\n            })\n        });\n\n        return pieces;\n    }\n\n    clearState() {\n        this.board.forEach(row => {\n            row.forEach(tile => {\n                tile.actions = [];\n\n                if (tile.piece) {\n                    tile.piece.actions = [];\n                }\n            })\n        })\n    }\n\n    toStore() {\n        return this.board;\n    }\n\n    static parseBoard(board) {\n        let parsedBoard = [];\n\n        let rows = board.split(';');\n        rows.splice(rows.length - 1, 1); //the final ; creates an off-by-one error, so remove the last element\n\n        //Split the rows, and trim the results\n        rows.forEach((row, yIndex) => {\n            let tiles = row.split(',');\n            tiles = tiles.map((tile, xIndex) => {\n                let token = tile.trim();\n                let piece = null;\n                if (token) {\n                    piece = {\n                        player: this.parsePlayer(token),\n                        type: this.parsePiece(token)\n                    }\n                }\n\n                return {\n                    x: xIndex,\n                    y: yIndex,\n                    piece: piece\n                };\n            });\n\n            parsedBoard.push(tiles)\n        });\n\n        return parsedBoard\n    }\n\n\n    static parsePlayer(token) {\n        if (typeof(token) !== 'string' && token.length !== 2) {\n            return null;\n        }\n\n        switch (token.charAt(0)) {\n            case 'B':\n                return 'black';\n            case 'W':\n                return 'white';\n            default:\n                return null;\n        }\n    }\n\n    static parsePiece(token) {\n        if (typeof(token) !== 'string' && token.length !== 2) {\n            return null;\n        }\n\n        switch (token.charAt(1)) {\n            case 'K':\n                return 'king';\n            case 'Q':\n                return 'queen';\n            case 'B':\n                return 'bishop';\n            case 'R':\n                return 'rook';\n            case 'N':\n                return 'knight';\n            case 'P':\n                return 'pawn';\n            default:\n                return null;\n        }\n    }\n}\n\nexport {\n    Board\n};","\nclass GameRule {\n\n    /**\n     * Hook to apply this rule at the start of a turn\n     * Use this to check for state-based actions, such as stalemate, or checkmate and marking allowed\n     * moves and attacks based on the current board state\n     * @param state\n     * @return new state\n     */\n    static atTurnStart(state) {return state;}\n\n    /**\n     * Hook to apply this rule before the current player takes a move\n     * Use this to apply rules that depend on other game rules, for instance checking that players have a valid move\n     * @param state\n     * @returns new state\n     */\n    static beforeMove(state) {return state;}\n\n    /**\n     * Execute moves based on this rule\n     * Use this to execute board state changes\n     * @param state\n     * @param action\n     * @return new state\n     */\n    static execute(state, action) {return state;}\n\n    /**\n     * Hook to apply this rule after the current player takes a move\n     * Use this to check for illegal board states\n     * @param state\n     * @returns {*}\n     */\n    static afterMove(state) {return state;}\n\n}\n\nexport {\n    GameRule\n}","\nimport { GameRule } from './GameRule';\n\nclass MoveRule extends GameRule {\n    static allowedMoves = [];\n    static type = '';\n    static repeat = true; // apply allowedMoves repeatedly\n\n    static atTurnStart(state) {\n        const tiles = state.board.getAllPiecesOfType(this.type);\n        tiles.forEach(this.markAllowedMoves.bind(this, state));\n\n        return state;\n    }\n\n    static execute(state, action) {\n        if (action.type !== 'MOVE_PIECE') return state;\n        if (action.piece.type !== this.type) return state;\n\n        const from = state.selectedTile;\n        const to = action.tile;\n\n        from.piece = null;\n        to.piece = action.piece;\n\n        return state;\n    }\n\n    static markAllowedMoves(state, tile) {\n        const piece = tile.piece;\n\n        this.allowedMoves.forEach(move => {\n            let {x, y} = tile;\n\n            x += move.x;\n            y += move.y;\n            let currentTile = state.board.getTile(x, y);\n\n            while (currentTile !== null) {\n                let attackAction = {\n                    type: 'ATTACK_PIECE',\n                    piece: piece,\n                    tile: currentTile\n                };\n                currentTile.actions.push(attackAction);\n                piece.actions.push(attackAction);\n\n                if (currentTile.piece && currentTile.piece.player === piece.player) break;\n\n                let moveAction = {\n                    type: 'MOVE_PIECE',\n                    piece: piece,\n                    tile: currentTile\n                };\n\n                currentTile.actions.push(moveAction);\n                piece.actions.push(moveAction);\n\n                if (currentTile.piece && currentTile.piece.player !== piece.player) break;\n                if (!this.repeat) break;\n\n                x += move.x;\n                y += move.y;\n                currentTile = state.board.getTile(x, y);\n            }\n        });\n    }\n}\n\nexport { MoveRule };","\nimport { MoveRule } from './MoveRule';\n\nclass MoveBishopRule extends MoveRule {\n    static allowedMoves = [\n        {x: 1, y: 1},\n        {x: 1, y: -1},\n        {x: -1, y: 1},\n        {x: -1, y: -1}\n    ];\n    static type = 'bishop';\n    static repeat = true;\n}\n\nexport default MoveBishopRule;","\nimport { MoveRule } from './MoveRule';\n\nclass MoveKingRule extends MoveRule {\n    static allowedMoves = [\n        {x: 0, y: 1},\n        {x: 0, y: -1},\n        {x: 1, y: 0},\n        {x: 1, y: 1},\n        {x: 1, y: -1},\n        {x: -1, y: 0},\n        {x: -1, y: 1},\n        {x: -1, y: -1}\n    ];\n    static type = 'king';\n    static repeat = false;\n}\n\nexport default MoveKingRule;","\nimport { MoveRule } from './MoveRule';\n\nclass MoveKnightRule extends MoveRule {\n    static allowedMoves = [\n        {x: 1, y: 2},\n        {x: 1, y: -2},\n        {x: -1, y: 2},\n        {x: -1, y: -2},\n        {x: 2, y: 1},\n        {x: 2, y: -1},\n        {x: -2, y: 1},\n        {x: -2, y: -1}\n    ];\n    static type = 'knight';\n    static repeat = false;\n}\n\nexport default MoveKnightRule;","\nimport { MoveRule } from './MoveRule';\n\nclass MovePawnRule extends MoveRule {\n    static type = 'pawn';\n    static repeat = false;\n\n    static markAllowedMoves(state, tile) {\n        const piece = tile.piece;\n        const direction = piece.player === 'white' ? -1 : 1;\n        const {x, y} = tile;\n\n        // Check whether the pawn can move forward\n        let currentTile = state.board.getTile(x, y + direction);\n        if (currentTile && !currentTile.piece) {\n            let action = {\n                type: 'MOVE_PIECE',\n                piece: piece,\n                tile: currentTile\n            };\n            currentTile.actions.push(action);\n            piece.actions.push(action);\n        }\n\n\n        // These are the diagonal capture moves\n        let diagonalCapture = [\n            {x: 1, y: direction},\n            {x: -1, y: direction}\n        ];\n        diagonalCapture.forEach(move => {\n            let currentTile = state.board.getTile(x+move.x, y+move.y);\n\n            if (currentTile !== null) {\n                let attackAction = {\n                    type: 'ATTACK_PIECE',\n                    piece: piece,\n                    tile: currentTile\n                };\n                currentTile.actions.push(attackAction);\n                piece.actions.push(attackAction);\n\n                if (currentTile.piece && currentTile.piece.player !== piece.player) {\n                    let moveAction = {\n                        type: 'MOVE_PIECE',\n                        piece: piece,\n                        tile: currentTile\n                    };\n\n                    currentTile.actions.push(moveAction);\n                    piece.actions.push(moveAction);\n                }\n            }\n        });\n    }\n}\n\nexport default MovePawnRule;","import { GameRule } from './GameRule';\n\nclass MovePawnTwoRule extends GameRule {\n\n    static atTurnStart(state) {\n        const tiles = state.board.getAllPiecesOfType('pawn');\n        tiles.forEach(this.markAllowedMoves.bind(this, state));\n\n        return state;\n    }\n\n    static markAllowedMoves(state, tile) {\n        const piece = tile.piece;\n        const direction = piece.player === 'white' ? -1 : 1;\n        const allowedRank = piece.player === 'white' ? 6 : 1;\n        const {x, y} = tile;\n\n        // Pawn is in the wrong place, so it's not eligible to move\n        if (y !== allowedRank) return;\n\n        // Check whether the pawn can move forward\n        let currentTile = state.board.getTile(x, y + direction);\n        if (currentTile.piece) return;\n\n        // Now check whether the pawn can move two forward\n        currentTile = state.board.getTile(x, y + (2 * direction));\n        if (currentTile.piece) return;\n\n        let moveAction = {\n            type: 'MOVE_PIECE',\n            piece: piece,\n            tile: currentTile\n        };\n\n        currentTile.actions.push(moveAction);\n        piece.actions.push(moveAction);\n    }\n}\n\nexport default MovePawnTwoRule;","\nimport { MoveRule } from './MoveRule';\n\nclass MoveQueenRule extends MoveRule {\n    static allowedMoves = [\n        {x: 0, y: 1},\n        {x: 0, y: -1},\n        {x: 1, y: 0},\n        {x: 1, y: 1},\n        {x: 1, y: -1},\n        {x: -1, y: 0},\n        {x: -1, y: 1},\n        {x: -1, y: -1}\n    ];\n    static type = 'queen';\n    static repeat = true;\n}\n\nexport default MoveQueenRule;","\nimport { MoveRule } from './MoveRule';\n\nclass MoveRookRule extends MoveRule {\n    static allowedMoves = [\n        {x: 0, y: 1},\n        {x: 0, y: -1},\n        {x: 1, y: 0},\n        {x: -1, y: 0},\n    ];\n    static type = 'rook';\n    static repeat = true;\n}\n\nexport default MoveRookRule;","\nimport MoveBishopRule from './rules/MoveBishopRule';\nimport MoveKingRule from './rules/MoveKingRule';\nimport MoveKnightRule from './rules/MoveKnightRule';\nimport MovePawnRule from './rules/MovePawnRule';\nimport MovePawnTwoRule from './rules/MovePawnTwoRule';\nimport MoveQueenRule from './rules/MoveQueenRule';\nimport MoveRookRule from './rules/MoveRookRule';\n\nimport CastleRule from './rules/CastleRule';\n\nconst GameRules = [\n    MoveBishopRule,\n    MoveKnightRule,\n    MoveKingRule,\n    MovePawnRule,\n    MovePawnTwoRule,\n    MoveQueenRule,\n    MoveRookRule,\n    CastleRule\n];\n\nexport {\n    GameRules,\n    MoveBishopRule,\n    MoveKnightRule,\n    MoveKingRule,\n    MovePawnRule,\n    MovePawnTwoRule,\n    MoveQueenRule,\n    MoveRookRule,\n    CastleRule\n};","\nimport { GameRule } from './GameRule';\n\nclass CastleRule extends GameRule {\n\n    static beforeMove(state) {\n        const tiles = state.board.getAllPiecesOfType('king');\n        tiles.forEach(this.markAllowedMoves.bind(this, state));\n\n        return state;\n    }\n\n    static execute(state, action) {\n        if (action.type !== 'CASTLE') return state;\n        if (action.piece.type !== 'king') return state;\n\n        const kingFrom = state.selectedTile;\n        const kingTo = action.tile;\n\n        const rookFrom = action.rook;\n        const rookTo = action.rookTile;\n\n        kingTo.piece = action.piece;\n        kingFrom.piece = null;\n\n        rookTo.piece = rookFrom.piece;\n        rookFrom.piece = null;\n\n        return state;\n    }\n\n    static markAllowedMoves(state, tile) {\n        const king = tile.piece;\n        const allowedRank = king.player === 'white' ? 7 : 0;\n\n        const kingRook = state.board.getTile(7, allowedRank);\n        const queenRook = state.board.getTile(0, allowedRank);\n\n        // Check whether the king has moved\n        if (this.hasMoved(state, tile)) { return; }\n\n        // Check the kingside castle\n        this.setupCastle(state, tile, kingRook, 1);\n        this.setupCastle(state, tile, queenRook, -1);\n    }\n\n    static setupCastle(state, king, rook, direction) {\n        // Check whether our rooks are actually rooks\n        if (!rook.piece\n            || rook.piece.type !== 'rook'\n            || rook.piece.player !== king.piece.player) {\n            return false;\n        }\n\n        let canCastle = !this.hasMoved(state, rook);\n        let castleTile = state.board.getTile(king.x + 2*direction, king.y);\n\n        // Make sure there are no pieces between the king and rook\n        let castleTiles = state.board.getTilesBetween(king, rook);\n        castleTiles.forEach(tile => {\n            if (tile.piece && tile.piece !== king.piece && tile.piece !== rook.piece) {\n                canCastle = false;\n            }\n        });\n\n        // Make sure the king doesn't move through check\n        castleTiles = state.board.getTilesBetween(king, castleTile);\n        castleTiles.forEach(tile => {\n            let actions = tile.actions.filter(action => {\n                return action.type === 'ATTACK_PIECE' && action.piece.player !== king.piece.player;\n            });\n            if (actions.length) {\n                canCastle = false;\n            }\n        });\n\n        if (canCastle) {\n            let action = {\n                type: 'CASTLE',\n                piece: king.piece,\n                rook: rook,\n                rookTile: state.board.getTile(king.x + direction, king.y),\n                tile: castleTile\n            };\n\n            castleTile.actions.push(action);\n            king.piece.actions.push(action);\n        }\n    }\n\n    static hasMoved(state, tile) {\n        let moved = false;\n        state.history.forEach((item) => {\n            // If a piece has moved to where the current piece is, it has moved before\n            if (item.to.x === tile.x && item.to.y === tile.y) {\n                moved = true;\n            }\n        });\n\n        return moved;\n    }\n}\n\nexport default CastleRule;","import { createStore } from 'redux';\n\nimport { Board } from './board';\nimport { GameRules } from './rules';\n\nconst board = `\n    BR,BN,BB,BQ,BK,BB,BN,BR;\n    BP,BP,BP,BP,BP,BP,BP,BP;\n    ,,,,,,,;\n    ,,,,,,,;\n    ,,,,,,,;\n    ,,,,,,,;\n    WP,WP,WP,WP,WP,WP,WP,WP;\n    WR,WN,WB,WQ,WK,WB,WN,WR;\n    `;\n\nconst defaultState = {\n    winner: false,\n    rejected: false,\n    player: 'white',\n    selectedTile: null,\n    board: Board.parseBoard(board),\n    history: []\n};\n\nconst store = createStore(function (state = defaultState, action) {\n    if (state.winner && action.type !== 'RESET_GAME') {\n        return state;\n    }\n\n    let oldState = state;\n    state = Object.assign({}, state);\n\n    console.log(state);\n    console.log(action);\n    switch (action.type) {\n        case 'SELECT_PIECE':\n            state = Object.assign(state, {\n                selectedTile: action.tile\n            });\n            return state;\n        case 'RESET_GAME':\n            return defaultState;\n        default:\n            // Default action is to forward the action to game rules and let them\n            // decide whether to act on an action\n            state.board = new Board(state.board);\n\n            // Execute the action\n            GameRules.forEach(rule => state = rule.execute(state, action));\n            GameRules.forEach(rule => state = rule.afterMove(state));\n\n            // Check whether the new game state has been rejected by a game rule during the afterMove step\n            // and needs to be aborted\n            if (state.rejected) {\n                return oldState;\n            }\n\n            if (action.tile) {\n                state.history.push({\n                    from: {x: state.selectedTile.x, y: state.selectedTile.y},\n                    to: {x: action.tile.x, y: action.tile.y}\n                });\n            }\n\n            // Start the next turn\n            if (action.type.indexOf('@@redux') < 0) {\n                state.player = state.player === 'white' ? 'black' : 'white';\n            }\n            state.board.clearState();\n            state.selectedTile = null;\n\n            GameRules.forEach(rule => state = rule.atTurnStart(state));\n            GameRules.forEach(rule => state = rule.beforeMove(state));\n\n            state.board = state.board.toStore();\n            return state;\n    }\n});\n\nexport default store;","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nimport '../styles/Piece.css';\n\nclass Tile extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  static parsePlayer(token) {\n    if (typeof(token) !== 'string' && token.length !== 2) { return null; }\n\n    switch(token.charAt(0)) {\n        case 'B':\n          return 'black';\n        case 'W':\n          return 'white';\n        default:\n          return null;\n    }\n  }\n\n  static parsePiece(token) {\n      if (typeof(token) !== 'string' && token.length !== 2) { return null; }\n\n      switch(token.charAt(1)) {\n          case 'K':\n              return 'king';\n          case 'Q':\n              return 'queen';\n          case 'B':\n              return 'bishop';\n          case 'R':\n              return 'rook';\n          case 'N':\n              return 'knight';\n          case 'P':\n              return 'pawn';\n          default:\n              return null;\n      }\n  }\n\n  getPiece() {\n      let piece = this.props.tile.piece;\n      let player = piece ? piece.player : '';\n\n      return player && piece ? `${player} ${piece.type}` : '';\n  }\n\n    /**\n     * Check whether this tile is the target of an action from the selected piece\n     * @returns {boolean}\n     */\n  isLegal() {\n      if (!this.props.selectedTile || !this.props.selectedTile.piece) { return false; }\n      let piece = this.props.selectedTile.piece;\n      let legal = false;\n\n        // Filter out actions on this tile that don't involve the correct piece\n        let actions = piece.actions.filter(action => {\n            return action.tile === this.props.tile && action.type !== 'ATTACK_PIECE'\n        });\n\n        actions.forEach((action) => {\n            if (action.tile.x === this.props.tile.x && action.tile.y === this.props.tile.y) {\n                legal = true;\n            }\n        });\n\n        return legal;\n  }\n\n  handleClick() {\n      let selectedTile = this.props.selectedTile;\n      if (selectedTile\n          && selectedTile.piece\n          && selectedTile.piece.player === this.props.player) {\n\n          // Filter out actions on this tile that don't involve the correct piece\n          let actions = this.props.tile.actions.filter(action => {\n              return action.piece === selectedTile.piece && action.type !== 'ATTACK_PIECE'\n          });\n\n          console.log(this.props.tile.actions);\n          console.log(actions);\n          actions.forEach((action) => {\n              this.props.dispatch(action)\n          });\n\n          if (actions.length) return;\n      }\n\n      this.props.dispatch({\n          type: 'SELECT_PIECE',\n          tile: this.props.tile\n      })\n  }\n\n  render() {\n      let legal = this.isLegal();\n      let selected = false;\n      if (this.props.selectedTile) {\n          selected = this.props.selectedTile.x === this.props.tile.x && this.props.selectedTile.y === this.props.tile.y;\n      }\n\n    return (\n      <div id={this.props.id}\n           data-x={this.props.tile.x}\n           data-y={this.props.tile.y}\n           className={`tile ${this.getPiece()} ${selected ? 'selected' : ''} ${legal ? 'legal' : ''}`}\n           onClick={this.handleClick.bind(this)} />\n    );\n  }\n}\n\nfunction stateMap(state) {\n    return {\n        player: state.player,\n        selectedTile: state.selectedTile\n    };\n}\n\nexport default connect(stateMap)(Tile);\n","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nimport Tile from './Tile';\nimport '../styles/Board.css';\n\nclass Board extends Component {\n    // constructor(props) {\n    //     super(props);\n    //\n    //     this.state = {\n    //         selectedTile: null,\n    //         board: props.board,\n    //         rotate: false,\n    //     };\n    // }\n\n    drawBoard() {\n        //Iterate over A->H to identify tiles (using ASCII char codes)\n        let charCode = 'A'.charCodeAt(0);\n        return this.props.board.map((row) => {\n            let output = [];\n            let counter = 0;\n\n            let tiles = row.map((tile) => {\n                let key = String.fromCharCode(charCode) + counter;\n                counter += 1;\n\n                return <Tile id={key} key={key} tile={tile} />;\n            });\n\n            output.push(<div key={String.fromCharCode(charCode)} className=\"row\">{tiles}</div>);\n\n            charCode += 1;\n            return output;\n        });\n    }\n\n    static parseRowCol(token) {\n        let row = token.charCodeAt(0) - 'A'.charCodeAt(0);\n        let col = parseInt(token.charAt(1));\n\n        return {row, col};\n    }\n\n    render() {\n        console.log(this.props);\n        return (\n            <div className={`board`}>\n                {this.drawBoard.apply(this)}\n            </div>\n        )\n\n    }\n}\n\nfunction mapStateToProps(state) {\n    return {\n        selectedTile: state.selectedTile,\n        board: state.board\n    }\n}\n\nexport default connect(mapStateToProps)(Board);","import React, { Component } from 'react';\nimport { Provider } from 'react-redux';\n\nimport store from '../data/store';\nimport Board from './Board';\nimport '../styles/App.css';\n\nclass App extends Component {\n  // constructor(props) {\n  //   super(props);\n  //\n  //   /* Set up the inital board state -- B / W for Black and White\n  //    * K = King, Q = Queen, B = Bishop, N = Knight, R = Rook, P = Pawn\n  //    */\n  //   let board = `\n  //   BR,BN,BB,BQ,BK,BB,BN,BR;\n  //   BP,BP,BP,BP,BP,BP,BP,BP;\n  //   ,,,,,,,;\n  //   ,,,,,,,;\n  //   ,,,,,,,;\n  //   ,,,,,,,;\n  //   WP,WP,WP,WP,WP,WP,WP,WP;\n  //   WR,WN,WB,WQ,WK,WB,WN,WR;\n  //   `;\n  //\n  //   this.state = {board: this.parseBoard(board)}\n  // }\n  //\n  // parseBoard(board) {\n  //   let parsedBoard = [];\n  //\n  //   let rows = board.split(';');\n  //   rows.splice(rows.length-1, 1); //the final ; creates an off-by-one error, so remove the last element\n  //\n  //   //Split the rows, and trim the results\n  //   rows.forEach(function(row) {\n  //     let tiles = row.split(',');\n  //     tiles = tiles.map((tile) => tile.trim());\n  //\n  //     parsedBoard.push(tiles)\n  //   });\n  //\n  //   return parsedBoard;\n  // }\n\n  render() {\n    return (\n      <Provider store={store}>\n        <div className=\"App\">\n          <Board />\n        </div>\n      </Provider>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}